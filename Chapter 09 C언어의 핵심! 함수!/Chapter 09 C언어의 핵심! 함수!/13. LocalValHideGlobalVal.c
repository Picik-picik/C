#include <stdio.h>
int Add(int val);
int num = 1;

int main(void) {
	int num = 5;

	printf("num : %d \n", Add(3));
	printf("num : %d \n", num + 9);

	return 0;
}

int Add(int val) {
	int num = 9;
	num += val;
	return num;
}

/*
전역변수와 동일한 이름의 지역변수가 선언되면 어떻게 되겠는가? 이 질문에 대해서는 다음 답변이 가장 유력하다.

"해당 지역 내에서는 전역변수가 가리워지고, 지역변수로의 접근이 이뤄집니다."

실행결과는 '동일한 이름의 지역변수는 해당영역 내에서 동일한 이름의 전역변수를 가린다'는 사실을
확인시켜준다. 위 예제 8행의 출력 결과가 12이다.
이는 인자로 전달된 정수 3이 15행에 선언된 지역변수 num과 더해진 결과이다.
9행의 출력 결과는 14이다. 이는 6행에 선언된 지역변수 num과 더해진 결과이다.

참고
- 이런 상황 자체를 만들지 않는 것이 좋겠지요.
필자는 C언어의 문법적 특성을 설명하기 위해서 전역변수와 동일한 이름의 지역변수를
선언하였는데 사실 이는 좋지 않은 습관이다. 가급적이면 변수의 이름은 달리해야 한다.
전역변수와 지역변수의 이름은 달리하는 것이 좋다.

전역변수! 괜찮은 것 같은데 좀 많이 써도 될까요?
전역변수! 품질이 괜찮아 보인다. 중간에 소멸되지도 않고 어디서든 접근이 가능하니 무적의 변수라
불릴만 하다. 하지만 전역변수의 선언은 가급적 제한해야 한다.
왜냐하면 전역변수는 프로그램의 구조를 복잡하게 만드는 주범이기 때문이다.

26개의 함수에 함수가 동시에 접근해야 할 변수가 있어 전역변수 10개 정도 된다고 가정하면 접근 형태가 매우 복잡하다.
그런 상황에서 int형으로 선언된 전역변수를 double형으로 변경해야 한다면 접근한 함수의 수만큼 변경해야 한다.
이렇듯 전역변수의 변경은 다수의 다른 함수까지 변경할 것을 요구한다.
전역변수에 접근하는 함수는 제한되어야 하지만, 실수로 다른 함수 내에서 접근이 이뤄졌다고 가정한다면
그 함수가 무엇인지 어떻게 찾을 것인가? 이는 26개의 모든 함수를 의심해야 하는 상황이다.

"전역변수의 수가 증가하면 그만큼 프로그램은 복잡해지며, 좋은 구조의 프로그램과는 거리가 멀어지게 된다.
 따라서 전역변수의 선언은 그만큼 신중해야 한다."

물론 전역변수를 선언할 수 밖에 없는 상황도 있다.(그러나 이러한 상황이 자주 등장하지는 않는다)
그리고 이러한 상황에서까지 전역변수를 선언하지 않으려고 억지로 노력하는 것은 바람직하지 않다.
오히려 프로그램을 더 복잡하게 만들 수도 있기 때문이다. 그러니 전역변수의 선언을 무조건 부정하지는 말자.

위 예시의 상황은 비약이 좀 심했다. 하지만 하나의 전역변수만으로도 충분히 프로그램이
복잡해질 수 있다는 사실을 알아야 한다.

참고
- 스파게티 코드(Spaghetti Code)
소프트웨어 공학에서는 전역변수의 과도한 선언과 같은 잘못된 프로그래밍 방식에 의해서 생성된 얽히고 설킨
코드를 가리켜 '스파게티 코드'라 한다.
*/