#include <stdio.h>

void Recursive(int num) {
	if (num <= 0) // 재귀의 탈출조건
		return;   // 재귀의 탈출!
	printf("Recursive call! %d \n", num);
	Recursive(num - 1);
}

int main(void) {
	Recursive(3);

	return 0;
}

/*
처음 C언어를 공부할 때는 '재귀함수'를 이해하는 것이 부담스러울 수 있다. 따라서 많이 부담스럽게 느껴진다면,
다음 기회에 공부할 것을 권하고 싶다. 어차피 진도를 나가는 데 지장 있는 내용은 아니니 말이다.
하지만 언젠간 반드시 공부해야 할 내용이다. 특히 자료구조와 알고리즘을 공부하기 전에는
반드시 학습해야 한다. 그럼 비교적 쉽게, 그리고 간단한 예제를 통해서 '재귀함수'를 설명하겠다.

재귀함수란 함수 내에서 자기 자신을 다시 호출하는 함수를 의미한다.

void Recursive(void) {
   printf("Recursive call! \n");
   Recursive(); // 나! 자신을 재 호출한다.
}

"완료되지 않은 함수를 다시 호출하는 것이 가능한 거야?" => YES!
"그것이 어떻게 가능해? 논리적으로 이치에 맞지 않는 것 같은데"

함수가 호출되면 해당 함수의 복사본을 만들어서 실행하는 구조이기 때문에 다음과 같은 논리적인 이해가 가능하다.

"Recursive 함수를 실행하는 중간에 다시 Recursive 함수가 호출되면, Recursive 함수의 복사본을 하나
 더 만들어서 복사본을 실행하게 됩니다."

위 문장의 내용은 재귀적인 형태의 함수호출이 가능한 이유를 충분히 설명하고 있다.
실제로 함수를 구성하는 명령문은 CPU로 이동이 되어서(복사가 되어서) 실행이 된다. 그런데 이 명령문은
얼마든지 CPU로 이동이(복사가) 가능하다. 따라서 Recursive 함수의 중간쯤 위치한 명령문을 실행하다가
(Recursive 함수의 실행을 완료하지 않은 상태에서) 다시 Recursive 함수의 앞 부분에 위치한 명령문을
CPU로 이동시키는 것은 문제가 되지 않는다. 그래서 재귀적인 형태의 함수호출이 가능한 것이다.

앞서 정의한 함수 Recursive는 한번 호출되면 계속해서 호출되는 문제가 있다.
이러한 문제는 Recursive 함수의 '재귀의 탈출조건'이 없다는데 원인이 있다.
탈출의 조건을 추가해서 예제를 완성해 보겠다.

Recursive 함수에 전달되는 인자의 값이 0이하인 겨우에는 함수가 종료되도록 정의되어 있다.
재귀적으로 호출이 이뤄지고 있는 Recursive 함수에 0이 전달되면서 '재귀의 탈출조건'이 성립되어
함수가 반환하기 시작한다. 반환하는 과정에서 마치 엉켜있는 실타래의 한 매듭이 풀리자
전체가 풀리는 듯한 느낌을 준다.
이로써 재귀함수의 대한 기본적인 설명은 다하였다.
이제 남은 것은 위에서 제시한 예제 및 그림을 보면서 여러분 나름의 이해를 완성하는 것이다.
*/