#include <stdio.h>

int main(void){
	/*
	double num1 = 245; // int형 정수 245를 double형으로 자동 형 변환 => 245.0
	int num2 = 3.1415; // double형 실수 3.1415를 int형으로 자동 형 변환 => 3으로 변환
	=> 실수형 데이터를 정수형 데이터로 변환하는 과정에서는 '소수부의 손실'이 발생한다.
	int num3 = 129;
	char ch = num;	// int형 변수 num3에 저장된 값이 char형으로 자동 형 변환
	129가 저장된 변수 num3의 비트 열 00000000 00000000 00000000 10000001 => 1바이트 크기로 줄여야 한다. => 상위 바이트의 손실 발생
	10000001 // 정수로 -127

	- 정수를 실수로 형 변환하는 경우
	정수에 해당하는 값을 실수로 표현하게 되는데, 실수의 표현범위가 정수에 비해 훨씬 넓기 때문에
	데이터의 손실은 일어나지 않는다. 다만, 실수의 표현이기 때문에 오차는 존재하게 된다.

	- 실수를 정수로 형 변환하는 경우
	정수는 소수점 이하의 값을 표현하지 못하기 때문에, 소수점 이하의 값은 버려진다.

	- 바이트 크기가 큰 정수를 바이트 크기가 작은 정수로 형 변환하는 경우
	변환하고자 하는 정수의 바이트 크기에 맞춰서 상위 바이트를 단순히 소멸시킨다.
	그리고 이로 인해 부호가 바뀔 수도 있으니, 주의가 필요하다.

	* 형 변환의 결과에 대한 내용은 다음의 규칙이 공통적으로 적용됨
	"데이터의 표현범위가 보다 넓은 자료형으로의 형 변환은, 그 과정에서 데이터 손실이 발생하지 않지만,
	데이터의 표현범위가 좁은 자료형의 형 변환은, 그 과정에서 데이터의 손실이 발생할 수 있다."
	*/

	double num1 = 245;
	int num2 = 3.1415;
	int num3 = 129;
	char ch = num3;

	printf("정수 245를 실수로 : %f\n", num1);
	printf("실수 3.1415를 정수로 : %d\n", num2);
	printf("큰 정수 129를 작은 정수로 : %d\n", ch);
	return 0;
	/*
	short = num1 = 15, num2 = 25;
	short = num1 + num2; // num1과 num2가 int형으로 형 변환
	이러한 형태의 형 변환을 '정수의 승격'이라 한다. 하지만 정수의 승격만 일어난 게 아님. 변수 num3에 저장하기 위해,
	대입연산 과정에서의 형 변환이 다시 일어나게 된다.

	오늘날의 컴퓨팅 환경에서 정수형 데이터의 연산속도는 거의 동일하다. CPU의 성능 및 구조가 이전과는 달리 많이 개선되어서
	정수형 데이터의 연산속도는 사실상 차이가 나지 않는다. 하지만 세상에는 많은 종류의 CPU가 있고, 새로운 CPU의 등장도 고려해야 하기 때문에
	C언어가 정의하는 '정수의 승격'은 여전히 의미를 갖는다.

	double num1 = 5.15 + 19; => int형 정수를 double형 실수로 형 변환
	피연산자의 자료형이 일치하지 않아서 발생하는 자동 형 변환은 데이터의 손실을 최소화하는 방향으로 진행
	int -> long -> long long -> float -> double -> long double
	ex) int형 정수와 long형 정수를 대상으로 덧셈연산을 하는 경우, long형 정수로 자동 형 변환
	double형 실수와 long형 정수를 대상으로 덧셈연산을 하는 경우, double형 실수로 자동 형 변환
	* char, short가 생략된 이유는 '정수의 승격'에 의해서 둘 다 int형 정수로 형 변환되기 때문이다.
	* 형 변환의 우선순위는 정수 자료형보다 실수 자료형이 무조건 앞서는 형태로 정의되어 있다.
	*/
}
